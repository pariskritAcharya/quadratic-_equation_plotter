<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quadratic Equation Plotter</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles to ensure a consistent look and feel */
        body {
            font-family: "Inter", sans-serif; /* Using Inter font as specified */
            background-color: #1a202c; /* Dark background for the body */
            color: #e2e8f0; /* Light text color */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            margin: 0;
            overflow-y: auto; /* Changed from overflow: hidden to allow vertical scrolling */
            overflow-x: hidden; /* Prevent horizontal scrollbar */
        }
        canvas {
            background-color: #2d3748; /* Slightly lighter dark background for the canvas */
            border-radius: 0.75rem; /* Rounded corners for the canvas */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Subtle shadow */
            touch-action: none; /* Disable default browser touch actions for custom panning and zooming */
        }
        /* Hide spin buttons for number inputs for a cleaner look */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox specific */
        }
    </style>
</head>
<body class="p-4">
    <div class="flex flex-col lg:flex-row gap-8 max-w-6xl w-full items-center lg:items-start">
        <!-- Controls Panel for constants -->
        <div class="bg-gray-800 p-6 rounded-xl shadow-lg flex flex-col gap-4 w-full lg:w-1/3">
            <h1 class="text-2xl font-bold text-center mb-4 text-blue-400">Quadratic Equation Plotter</h1>

            <!-- Display for the current equation -->
            <div class="text-center text-lg mb-4 p-2 bg-gray-700 rounded-md" id="equationDisplay">
                Equation: $ax^2 + 2hxy + by^2 + 2gx + 2fy + c = 0$
            </div>

            <!-- Input fields for the constants -->
            <div class="grid grid-cols-2 gap-4">
                <div class="flex flex-col">
                    <label for="a" class="text-sm font-medium mb-1">a:</label>
                    <input type="number" id="a" value="1" step="0.1" class="p-2 rounded-md bg-gray-700 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col">
                    <label for="h" class="text-sm font-medium mb-1">h:</label>
                    <input type="number" id="h" value="1" step="0.1" class="p-2 rounded-md bg-gray-700 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col">
                    <label for="b" class="text-sm font-medium mb-1">b:</label>
                    <input type="number" id="b" value="4" step="0.1" class="p-2 rounded-md bg-gray-700 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col">
                    <label for="g" class="text-sm font-medium mb-1">g:</label>
                    <input type="number" id="g" value="0" step="0.1" class="p-2 rounded-md bg-gray-700 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col">
                    <label for="f" class="text-sm font-medium mb-1">f:</label>
                    <input type="number" id="f" value="0" step="0.1" class="p-2 rounded-md bg-gray-700 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex flex-col">
                    <label for="c" class="text-sm font-medium mb-1">c:</label>
                    <input type="number" id="c" value="-30" step="0.1" class="p-2 rounded-md bg-gray-700 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>

            <!-- Button to reset the view (pan and zoom) -->
            <button id="resetViewBtn" class="mt-4 p-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors shadow-md">Reset View</button>
        </div>

        <!-- Graph and Quick Draw Buttons Container -->
        <div class="flex flex-col items-center w-full lg:w-2/3">
            <!-- Canvas element where the graph will be drawn -->
            <canvas id="graphCanvas" width="800" height="600" class="w-full"></canvas>

            <!-- Quick Draw Buttons -->
            <div class="mt-6 p-4 bg-gray-800 rounded-xl shadow-lg grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-4 w-full">
                <button id="drawCircleBtn" class="p-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors shadow-md">Circle</button>
                <button id="drawParabolaBtn" class="p-3 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors shadow-md">Parabola</button>
                <button id="drawHyperbolaBtn" class="p-3 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors shadow-md">Hyperbola</button>
                <button id="drawEllipseBtn" class="p-3 bg-yellow-600 text-white rounded-md hover:bg-yellow-700 transition-colors shadow-md">Ellipse</button>
                <button id="drawLineBtn" class="p-3 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors shadow-md">Line (Pair)</button>
                <button id="drawPointBtn" class="p-3 bg-pink-600 text-white rounded-md hover:bg-pink-700 transition-colors shadow-md">Point</button>
            </div>
        </div>
    </div>

    <script>
        // Get references to the canvas and its 2D rendering context
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        // Get references to input fields and equation display
        const aInput = document.getElementById('a');
        const hInput = document.getElementById('h');
        const bInput = document.getElementById('b');
        const gInput = document.getElementById('g');
        const fInput = document.getElementById('f');
        const cInput = document.getElementById('c');
        const equationDisplay = document.getElementById('equationDisplay');
        const resetViewBtn = document.getElementById('resetViewBtn');

        // Get references to quick draw buttons
        const drawCircleBtn = document.getElementById('drawCircleBtn');
        const drawParabolaBtn = document.getElementById('drawParabolaBtn');
        const drawHyperbolaBtn = document.getElementById('drawHyperbolaBtn');
        const drawEllipseBtn = document.getElementById('drawEllipseBtn');
        const drawLineBtn = document.getElementById('drawLineBtn');
        const drawPointBtn = document.getElementById('drawPointBtn');

        // View state variables for panning and zooming
        let view = {
            offsetX: 0, // X-offset for panning
            offsetY: 0, // Y-offset for panning
            scale: 50   // Pixels per unit (zoom level)
        };

        // Desired line thickness for the current plot
        let desiredThickness = 2; // Default line thickness in pixels

        // Variables for mouse interaction (panning)
        let isDragging = false;
        let lastMouseX, lastMouseY;

        // Variables for touch interaction (panning and zooming)
        let initialPinchDistance = null;
        let lastTouchX = null;
        let lastTouchY = null;

        /**
         * Reads the current values of the constants from the input fields.
         * @returns {object} An object containing the parsed float values of a, h, b, g, f, c.
         */
        function getConstants() {
            return {
                a: parseFloat(aInput.value),
                h: parseFloat(hInput.value),
                b: parseFloat(bInput.value),
                g: parseFloat(gInput.value),
                f: parseFloat(fInput.value),
                c: parseFloat(cInput.value)
            };
        }

        /**
         * Sets the values of the constants in the input fields.
         * @param {object} constants - An object containing the new values for a, h, b, g, f, c.
         * @param {number} [thickness=2] - Optional: The desired line thickness in pixels.
         */
        function setConstants(constants, thickness = 2) {
            aInput.value = constants.a;
            hInput.value = constants.h;
            bInput.value = constants.b;
            gInput.value = constants.g;
            fInput.value = constants.f;
            cInput.value = constants.c;
            desiredThickness = thickness; // Set the desired line thickness
            updateEquationDisplay(); // Update equation text after setting values
            drawGraph(); // Redraw graph with new values
        }

        /**
         * Updates the displayed quadratic equation string based on current constant values.
         */
        function updateEquationDisplay() {
            const { a, h, b, g, f, c } = getConstants();
            let eqString = '';

            // Helper to format terms, avoiding "+ -" and "1x"
            const formatTerm = (coeff, variable, includePlus = true) => {
                if (coeff === 0) return '';
                let sign = coeff > 0 ? (includePlus ? '+' : '') : '-';
                let absCoeff = Math.abs(coeff);
                let coeffStr = absCoeff === 1 && variable !== '' ? '' : absCoeff.toFixed(2).replace(/\.00$/, ''); // Remove .00 for integers

                return `${sign}${coeffStr}${variable}`;
            };

            eqString += formatTerm(a, 'x\u00B2', false); // x^2 term, no leading '+'
            eqString += formatTerm(2 * h, 'xy'); // 2hxy term
            eqString += formatTerm(b, 'y\u00B2'); // y^2 term
            eqString += formatTerm(2 * g, 'x'); // 2gx term
            eqString += formatTerm(2 * f, 'y'); // 2fy term
            eqString += formatTerm(c, ''); // c term

            // If equation is empty (all zeros), display the general form
            if (eqString === '') {
                equationDisplay.textContent = 'Equation: 0 = 0 (or adjust constants)';
            } else {
                // Remove leading '+' if it exists (only for the first term)
                if (eqString.startsWith('+')) {
                    eqString = eqString.substring(1);
                }
                equationDisplay.textContent = `Equation: ${eqString} = 0`;
            }
        }

        /**
         * Converts canvas pixel coordinates to mathematical (graph) coordinates.
         * @param {number} px - X-pixel coordinate.
         * @param {number} py - Y-pixel coordinate.
         * @returns {object} An object with x and y mathematical coordinates.
         */
        function transformPoint(px, py) {
            const x = (px - canvas.width / 2 - view.offsetX) / view.scale;
            const y = (canvas.height / 2 - py + view.offsetY) / view.scale;
            return { x, y };
        }

        /**
         * Converts mathematical (graph) coordinates to canvas pixel coordinates.
         * @param {number} x - X mathematical coordinate.
         * @param {number} y - Y mathematical coordinate.
         * @returns {object} An object with px and py pixel coordinates.
         */
        function untransformPoint(x, y) {
            const px = x * view.scale + canvas.width / 2 + view.offsetX;
            const py = canvas.height / 2 - y * view.scale + view.offsetY;
            return { px, py };
        }

        /**
         * Draws the X and Y axes and grid lines on the canvas.
         */
        function drawAxes() {
            ctx.strokeStyle = '#4a5568'; // Axis color
            ctx.lineWidth = 1;

            // Draw X-axis (mathematical y=0)
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2 + view.offsetY);
            ctx.lineTo(canvas.width, canvas.height / 2 + view.offsetY);
            ctx.stroke();

            // Draw Y-axis (mathematical x=0)
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2 + view.offsetX, 0);
            ctx.lineTo(canvas.width / 2 + view.offsetX, canvas.height);
            ctx.stroke();

            ctx.font = '12px Inter';
            ctx.fillStyle = '#cbd5e0'; // Label color

            // Draw grid lines and labels
            const gridSpacing = view.scale; // 1 unit in math space = view.scale pixels
            const labelOffset = 5; // Offset for labels from axes

            // Vertical grid lines and X-axis labels
            for (let i = -canvas.width / 2 - view.offsetX; i < canvas.width / 2 - view.offsetX; i += gridSpacing) {
                const xCoord = Math.round(i / gridSpacing);
                if (xCoord !== 0) { // Don't draw label for origin
                    const { px } = untransformPoint(xCoord, 0);
                    ctx.beginPath();
                    ctx.moveTo(px, 0);
                    ctx.lineTo(px, canvas.height);
                    ctx.strokeStyle = '#2d3748'; // Lighter grid color
                    ctx.stroke();
                    // X-axis labels: Corrected Y-coordinate for labels
                    ctx.fillText(xCoord.toString(), px + labelOffset, canvas.height / 2 + view.offsetY + 15);
                }
            }

            // Horizontal grid lines and Y-axis labels
            for (let i = -canvas.height / 2 + view.offsetY; i < canvas.height / 2 + view.offsetY; i += gridSpacing) {
                const yCoord = Math.round(i / gridSpacing);
                if (yCoord !== 0) { // Don't draw label for origin
                    const { py } = untransformPoint(0, yCoord);
                    ctx.beginPath();
                    ctx.moveTo(0, py);
                    ctx.lineTo(canvas.width, py);
                    ctx.strokeStyle = '#2d3748'; // Lighter grid color
                    ctx.stroke();
                    // Y-axis labels
                    ctx.fillText(yCoord.toString(), canvas.width / 2 + view.offsetX + labelOffset, py - labelOffset);
                }
            }
        }

        /**
         * Draws the quadratic equation on the canvas by detecting sign changes.
         * This creates smooth lines instead of filled areas.
         */
        function drawQuadratic() {
            // Clear the entire canvas before redrawing
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes and grid first
            drawAxes();

            const { a, h, b, g, f, c } = getConstants();

            // Special handling for the "Point" case (x^2 + y^2 = 0)
            // This equation only has a solution at (0,0), so drawing a line segment won't work.
            if (a === 1 && h === 0 && b === 1 && g === 0 && f === 0 && c === 0) {
                ctx.fillStyle = '#63b3ed'; // Blue color for the point
                const { px, py } = untransformPoint(0, 0); // Get canvas coords of origin
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2); // Draw a small circle for the point
                ctx.fill();
                return; // Exit function after drawing the point
            }

            ctx.strokeStyle = '#63b3ed'; // Blue color for the lines
            ctx.lineWidth = desiredThickness; // Use the desired thickness

            const resolution = 1; // Check every pixel for sign changes

            // Iterate through the canvas pixels
            for (let py = 0; py < canvas.height; py += resolution) {
                for (let px = 0; px < canvas.width; px += resolution) {
                    // Get mathematical coordinates for current pixel
                    const { x, y } = transformPoint(px, py);
                    const F_current = a * x * x + 2 * h * x * y + b * y * y + 2 * g * x + 2 * f * y + c;

                    // Check right neighbor
                    const { x: x_right, y: y_right } = transformPoint(px + resolution, py);
                    const F_right = a * x_right * x_right + 2 * h * x_right * y_right + b * y_right * y_right + 2 * g * x_right + 2 * f * y_right + c;

                    // Check down neighbor
                    const { x: x_down, y: y_down } = transformPoint(px, py + resolution);
                    const F_down = a * x_down * x_down + 2 * h * x_down * y_down + b * y_down * y_down + 2 * g * x_down + 2 * f * y_down + c;

                    // Horizontal crossing: if F_current and F_right have different signs (or one is zero)
                    if (F_current * F_right <= 0) {
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + resolution, py);
                        ctx.stroke();
                    }

                    // Vertical crossing: if F_current and F_down have different signs (or one is zero)
                    if (F_current * F_down <= 0) {
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px, py + resolution);
                        ctx.stroke();
                    }
                }
            }
        }

        /**
         * This function orchestrates the drawing of the entire graph.
         * It clears the canvas, then draws the quadratic equation.
         */
        function drawGraph() {
            drawQuadratic();
        }

        /**
         * Resets the view (pan and zoom) to its initial state.
         */
        function resetView() {
            view.offsetX = 0;
            view.offsetY = 0;
            view.scale = 50;
            desiredThickness = 2; // Reset thickness to default for general curves
            drawGraph(); // Redraw the graph with the reset view
        }

        // --- Event Listeners ---

        // Listen for changes on any input field to redraw the graph
        [aInput, hInput, bInput, gInput, fInput, cInput].forEach(input => {
            input.addEventListener('input', () => {
                desiredThickness = 2; // Reset to default thickness when manually typing
                updateEquationDisplay(); // Update equation text
                drawGraph(); // Redraw graph
            });
        });

        // Listen for click on reset view button
        resetViewBtn.addEventListener('click', resetView);

        // Quick draw button event listeners
        drawCircleBtn.addEventListener('click', () => {
            setConstants({ a: 1, h: 0, b: 1, g: 0, f: 0, c: -25 }, 2); // Example: x^2 + y^2 = 25
        });

        drawParabolaBtn.addEventListener('click', () => {
            setConstants({ a: 1, h: 0, b: 0, g: 0, f: -1, c: 0 }, 2); // Example: x^2 = 2y
        });

        drawHyperbolaBtn.addEventListener('click', () => {
            setConstants({ a: 1, h: 0, b: -1, g: 0, f: 0, c: -1 }, 2); // Example: x^2 - y^2 = 1
        });

        drawEllipseBtn.addEventListener('click', () => {
            setConstants({ a: 4, h: 0, b: 1, g: 0, f: 0, c: -16 }, 2); // Example: 4x^2 + y^2 = 16
        });

        drawLineBtn.addEventListener('click', () => {
            // x^2 - 5xy + 6y^2 = 0
            // (x - 2y)(x - 3y) = 0
            // a=1, 2h=-5 => h=-2.5, b=6, g=0, f=0, c=0
            setConstants({ a: 1, h: -2.5, b: 6, g: 0, f: 0, c: 0 }, 0.5); // Very thin lines
        });

        drawPointBtn.addEventListener('click', () => {
            setConstants({ a: 1, h: 0, b: 1, g: 0, f: 0, c: 0 }, 0.5); // x^2 + y^2 = 0 (only at origin)
        });

        // --- Mouse Events ---
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                view.offsetX += dx;
                view.offsetY += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                drawGraph();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.1;
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;

            const { x: mouseGraphX, y: mouseGraphY } = transformPoint(mouseX, mouseY);

            if (e.deltaY < 0) { // Zoom in
                view.scale *= zoomFactor;
            } else { // Zoom out
                view.scale /= zoomFactor;
            }

            const { px: newMousePx, py: newMousePy } = untransformPoint(mouseGraphX, mouseGraphY);
            view.offsetX += (mouseX - newMousePx);
            view.offsetY += (mouseY - newMousePy);

            drawGraph();
        });

        // --- Touch Events for Mobile Panning and Pinch-to-Zoom ---
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default touch actions like scrolling/native zoom
            if (e.touches.length === 1) {
                // Single touch for panning
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Two touches for pinch-to-zoom
                isDragging = false; // Disable panning if pinching
                initialPinchDistance = getPinchDistance(e.touches);
                // Store initial center point for zooming around
                const touchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const touchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                lastTouchX = touchCenterX;
                lastTouchY = touchCenterY;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent default touch actions
            if (e.touches.length === 1 && isDragging) {
                // Pan with single touch
                const dx = e.touches[0].clientX - lastTouchX;
                const dy = e.touches[0].clientY - lastTouchY;
                view.offsetX += dx;
                view.offsetY += dy;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                drawGraph();
            } else if (e.touches.length === 2 && initialPinchDistance !== null) {
                // Pinch-to-zoom with two touches
                const currentPinchDistance = getPinchDistance(e.touches);
                if (currentPinchDistance === 0) return; // Avoid division by zero

                const zoomFactor = currentPinchDistance / initialPinchDistance;
                const oldScale = view.scale;
                view.scale *= zoomFactor;

                // Calculate the center of the pinch gesture in canvas coordinates
                const touchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - canvas.getBoundingClientRect().left;
                const touchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - canvas.getBoundingClientRect().top;

                // Adjust offsets to zoom around the pinch center
                view.offsetX = touchCenterX - (touchCenterX - view.offsetX) * (view.scale / oldScale);
                view.offsetY = touchCenterY - (touchCenterY - view.offsetY) * (view.scale / oldScale);

                initialPinchDistance = currentPinchDistance; // Update for next move
                drawGraph();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            isDragging = false;
            initialPinchDistance = null; // Reset pinch state
            lastTouchX = null;
            lastTouchY = null;
        });

        /**
         * Calculates the distance between two touch points.
         * @param {TouchList} touches - The list of touch points.
         * @returns {number} The distance between the first two touch points.
         */
        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Handle window resize to make the canvas responsive
        window.addEventListener('resize', () => {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = Math.min(600, parent.clientHeight * 0.75); // Adjusted height
            drawGraph(); // Redraw graph after resize
        });

        // Initial setup when the page loads
        window.onload = function() {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = Math.min(600, parent.clientHeight * 0.75); // Adjusted height

            updateEquationDisplay(); // Display initial equation
            drawGraph(); // Draw the initial graph
            canvas.style.cursor = 'grab'; // Set initial cursor
        };
    </script>
</body>
</html>
